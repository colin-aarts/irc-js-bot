// Generated by IcedCoffeeScript 1.3.3b
(function() {
  'use strict';

  var IRC, Log, bot, fs, iced, js, util, __iced_k, __iced_k_noop,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  iced = {
    Deferrals: (function() {

      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) return this.continuation(this.ret);
      };

      _Class.prototype.defer = function(defer_params) {
        var _this = this;
        ++this.count;
        return function() {
          var inner_params, _ref;
          inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (defer_params != null) {
            if ((_ref = defer_params.assign_fn) != null) {
              _ref.apply(null, inner_params);
            }
          }
          return _this._fulfill();
        };
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    }
  };
  __iced_k = __iced_k_noop = function() {};

  util = require('util');

  fs = require('fs');

  IRC = require('irc-js');

  Log = require('coloured-log');

  js = (require('js-extensions')).local;

  bot = {
    init: function() {
      this.factoids = this.load_factoids();
      this.log = new Log(Log.DEBUG);
      this.log.prefix = "[" + this.irc_options.nick + "]";
      this.backlog = {};
      this.re_triggers = (this.bot_options.triggers.map(function(trigger) {
        return js.re_escape(trigger);
      })).join('|');
      this.message_callbacks = [];
      this.special_commands = {};
      this.plugins = this.load_plugins();
      this.irc = new IRC(this.irc_options);
      return this.connect();
    },
    connect: function() {
      var channel, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src\index.coffee",
          funcname: "connect"
        });
        _this.irc.connect(__iced_deferrals.defer({
          lineno: 45
        }));
        __iced_deferrals._fulfill();
      })(function() {
        var _i, _len, _ref;
        _this.log.info("" + _this.log.prefix + " Connected to network (" + _this.irc_options.server + ").");
        _ref = _this.irc_options.channels;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          channel = _ref[_i];
          _this.irc.join(channel);
        }
        return _this.irc.addListener('privmsg', function(event) {
          var callback_results, fn, input_data, input_match, output_data, result, _base, _j, _k, _len1, _len2, _name, _ref1;
          event.recipient = event.params[0];
          event.message = event.params[1];
          if (event.recipient[0] === '#') {
            (_base = _this.backlog)[_name = event.recipient] || (_base[_name] = []);
            _this.backlog[event.recipient].unshift(event.message);
            if (_this.backlog[event.recipient].length > 100) {
              _this.backlog[event.recipient].pop();
            }
          }
          input_match = event.message.match(RegExp("^(" + _this.re_triggers + ")(.+?)((\\\\s+([@>%])\\\\s+)(.*?))?((?:\\\\s+\\#\\\\s*)(.*))?$", "i"));
          if (!input_match) return;
          input_data = {
            trigger: input_match[1],
            command: input_match[2],
            target_method: input_match[5],
            target: input_match[6],
            comment: input_match[8],
            is_special: false,
            args: '',
            flags: []
          };
          (function() {
            var command_match;
            command_match = input_data.command.match(/^(\S+?)(\\/(\S+))?(\s+(.+))?$/);
            if (command_match && command_match[1] in _this.special_commands) {
              input_data.is_special = true;
              input_data.command = command_match[1];
              if (command_match[3]) input_data.flags = command_match[3].split('');
              return input_data.args = command_match[5] || '';
            }
          })();
          output_data = _this.get_output_data(event, input_data);
          _this.log.info("" + _this.log.prefix + " Command received …\n" + (util.inspect(input_data)) + "\n" + (util.inspect(output_data)));
          callback_results = [];
          _ref1 = _this.message_callbacks;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            fn = _ref1[_j];
            callback_results.push(fn(event, input_data, output_data));
          }
          for (_k = 0, _len2 = callback_results.length; _k < _len2; _k++) {
            result = callback_results[_k];
            if (result === false) return;
          }
          if (input_data.is_special) {
            return _this.handle_command(event, input_data, output_data);
          } else {
            return _this.handle_factoid(event, input_data, output_data);
          }
        });
      });
    },
    load_factoids: function() {
      var factoids_json;
      factoids_json = fs.readFileSync("" + (process.cwd()) + "/factoids.json", 'utf-8');
      if (!factoids_json) return;
      return JSON.parse(factoids_json);
    },
    save_factoids: function() {
      var factoids_json;
      factoids_json = JSON.stringify(this.factoids);
      return fs.writeFile("" + (process.cwd()) + "/factoids.json", factoids_json, 'utf-8');
    },
    load_plugins: function() {
      var plugin_name, plugins, _i, _len, _ref;
      plugins = {};
      _ref = this.bot_options.plugins;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        plugin_name = _ref[_i];
        plugins[plugin_name] = (require(plugin_name)).call(this);
      }
      return plugins;
    },
    send: function(method, target, messages) {
      var iter,
        _this = this;
      if (!Array.isArray(messages)) messages = [messages];
      return (iter = function() {
        if (messages.length) {
          _this.irc[method](target, messages.shift(), true);
          if (messages.length) return setTimeout(iter, 1000);
        }
      })();
    },
    format_output: function(message, input_data) {
      if (Array.isArray(message)) return;
      if (input_data.target && input_data.target_method === '@') {
        return "" + input_data.target + ", " + message;
      }
      return message;
    },
    get_output_data: function(event, input_data) {
      var output_data;
      output_data = {
        recipient: void 0,
        method: void 0,
        is_admin: false
      };
      if (input_data.target) {
        switch (input_data.target_method) {
          case '>':
          case '%':
            output_data.recipient = input_data.target;
            break;
          case '@':
            output_data.recipient = event.recipient;
        }
      } else if (event.recipient[0] === '#') {
        output_data.recipient = event.recipient;
      } else {
        output_data.recipient = event.person.nick;
      }
      if (input_data.target_method === '%') {
        output_data.method = 'notice';
      } else {
        output_data.method = 'privmsg';
      }
      output_data.is_admin = this.user_match(this.bot_options.admins, {
        nick: event.person.nick,
        host: event.person.host
      });
      return output_data;
    },
    handle_factoid: function(event, input_data, output_data) {
      var alias_target, alias_target_exists, factoid_content, factoid_exists, factoid_name, is_alias, message;
      factoid_name = input_data.command;
      factoid_exists = factoid_name in this.factoids;
      if (factoid_exists) {
        factoid_content = this.factoids[factoid_name];
        is_alias = /^alias:/.test(factoid_content);
        if (is_alias) {
          alias_target = factoid_content.replace(/^alias:/, '');
          alias_target_exists = alias_target in this.factoids;
          if (!alias_target_exists) {
            message = "« " + factoid_name + " » is an alias leading to a non-existent factoid « " + alias_target + " »; please contact an administrator (see « " + input_data.trigger + "admins ») so they can clean it up :)";
          } else {
            message = this.factoids[alias_target];
          }
        } else {
          message = factoid_content;
        }
        message = this.format_output(message, input_data);
      } else {
        message = "" + event.person.nick + ", no such command '" + factoid_name + "'. Try " + input_data.trigger + "search <query> to search for factoids or see " + input_data.trigger + "commands";
      }
      return this.send(output_data.method, output_data.recipient, message);
    },
    handle_command: function(event, input_data, output_data) {
      var command, message;
      command = this.special_commands[input_data.command];
      if ((!command.admin_only) || (command.admin_only && output_data.is_admin)) {
        return command.fn(event, input_data, output_data);
      } else {
        message = 'Sorry, you have to be an admin to use this command';
        return this.send('notice', event.person.nick, message);
      }
    },
    factoid_get_aliases: function(needle) {
      var aliases, factoid_content, factoid_name, _ref;
      aliases = [];
      _ref = this.factoids;
      for (factoid_name in _ref) {
        if (!__hasProp.call(_ref, factoid_name)) continue;
        factoid_content = _ref[factoid_name];
        if (factoid_content === ("alias:" + needle)) aliases.push(factoid_name);
      }
      if (aliases.length) {
        return aliases;
      } else {
        return null;
      }
    },
    user_match: function(user_list, target_user) {
      var is_host_match, is_match, iterated_user, _i, _len;
      is_match = false;
      for (_i = 0, _len = user_list.length; _i < _len; _i++) {
        iterated_user = user_list[_i];
        is_host_match = iterated_user.host !== null ? (new RegExp("" + (js.re_escape(iterated_user.host)) + "$", 'i')).test(target_user.host) : false;
        if ((iterated_user.nick && iterated_user.nick === target_user.nick && !iterated_user.host) || (iterated_user.host && is_host_match && !iterated_user.nick) || (iterated_user.host && is_host_match && iterated_user.nick && iterated_user.nick === target_user.nick)) {
          is_match = true;
        }
      }
      return is_match;
    },
    register_special_command: function(data) {
      if (!data || !data.name || !data.fn) {
        this.log.info("" + this.log.prefix + " Could not load plug-in command '" + data.name + "'");
        return;
      }
      if (data.name in this.special_commands) {
        this.log.info("" + this.log.prefix + " Command '" + data.name + " of plug-in " + data.plugin + " already exists. Aborting.");
        return;
      }
      return this.special_commands[data.name] = {
        name: data.name,
        description: data.description,
        admin_only: data.admin_only || false,
        fn: data.fn
      };
    },
    register_message_callback: function(fn) {
      if (!fn) {
        this.log.info("" + this.log.prefix + " Could not register message callback");
        return;
      }
      return this.message_callbacks.push(fn);
    }
  };

  module.exports = function(irc_options, bot_options) {
    var a_bot;
    a_bot = Object.create(bot, {
      irc_options: {
        value: irc_options
      },
      bot_options: {
        value: bot_options
      }
    });
    a_bot.init();
    return a_bot;
  };

}).call(this);
