// Generated by IcedCoffeeScript 1.3.3b
(function() {
  'use strict';

  var iced, js, util, __iced_k, __iced_k_noop,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  iced = {
    Deferrals: (function() {

      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) return this.continuation(this.ret);
      };

      _Class.prototype.defer = function(defer_params) {
        var _this = this;
        ++this.count;
        return function() {
          var inner_params, _ref;
          inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (defer_params != null) {
            if ((_ref = defer_params.assign_fn) != null) {
              _ref.apply(null, inner_params);
            }
          }
          return _this._fulfill();
        };
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    }
  };
  __iced_k = __iced_k_noop = function() {};

  util = require('util');

  js = (require('js-extensions')).local;

  module.exports = function() {
    var _this = this;
    this.register_special_command({
      name: 'admins',
      description: 'Display a list of my administrators',
      admin_only: false,
      fn: function(event, input_data, output_data) {
        var admin, host, message, nick, _i, _len, _ref;
        if (__indexOf.call(input_data.flags, '?') >= 0) {
          message = 'Display a list of my administrators';
        } else {
          message = [];
          _ref = _this.bot_options.admins;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            admin = _ref[_i];
            nick = admin.nick || '(null)';
            host = admin.host || '(null)';
            message.push("nick: " + nick + " • host: " + host);
          }
        }
        return _this.send('notice', event.person.nick, message);
      }
    });
    this.register_special_command({
      name: 'commands',
      description: 'Display a list of special commands I support',
      admin_only: false,
      fn: function(event, input_data, output_data) {
        var command, message, name, permission, _ref;
        if (__indexOf.call(input_data.flags, '?') >= 0) {
          message = ['Syntax: commands[/v] • Display a list of special commands I support', '--- This command supports the following flags ---', 'v • verbose: also lists the description and permission level for each command'];
        } else if (__indexOf.call(input_data.flags, 'v') >= 0) {
          message = [];
          _ref = _this.special_commands;
          for (name in _ref) {
            if (!__hasProp.call(_ref, name)) continue;
            command = _ref[name];
            permission = command.admin_only ? ' • admin only' : '';
            message.push("" + command.name + " • " + command.description + permission);
          }
        } else {
          message = (function() {
            var _ref1, _results;
            _ref1 = this.special_commands;
            _results = [];
            for (name in _ref1) {
              if (!__hasProp.call(_ref1, name)) continue;
              _results.push(name);
            }
            return _results;
          }).call(_this);
          message = message.join(' • ');
        }
        return _this.send('notice', event.person.nick, message);
      }
    });
    this.register_special_command({
      name: 'topic',
      description: 'Display the topic for the current channel; only works in channels',
      admin_only: false,
      fn: function(event, input_data, output_data) {
        var channel, message, ___iced_passed_deferral, __iced_deferrals, __iced_k;
        __iced_k = __iced_k_noop;
        ___iced_passed_deferral = iced.findDeferral(arguments);
        (function(__iced_k) {
          if (__indexOf.call(input_data.flags, '?') >= 0) {
            return __iced_k(message = 'Display the channel topic for the current channel; only works in channels');
          } else {
            if (event.recipient[0] !== '#') return;
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "node_modules\irc-js-bot\node_modules\irc-js-bot-util\index.coffee",
                funcname: "fn"
              });
              _this.irc.topic(event.recipient, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    channel = arguments[0];
                    return message = arguments[1];
                  };
                })(),
                lineno: 85
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          }
        })(function() {
          return _this.send(output_data.method, output_data.recipient, message);
        });
      }
    });
    this.register_special_command({
      name: 'info',
      description: 'Display information about a factoid',
      admin_only: false,
      fn: function(event, input_data, output_data) {
        var aliases, factoid_content, factoid_name, factoid_original_content, factoid_original_name, is_alias, message;
        if (__indexOf.call(input_data.flags, '?') >= 0) {
          message = "info <factoid-name> • Display information about a factoid";
        } else if (!input_data.args.trim()) {
          message = "Sorry, I didn't see a factoid name there!";
        } else if (!input_data.args.trim() in _this.factoids) {
          message = "Sorry, I couldn't find a factoid with the name « " + input_data.args + " »";
        } else {
          message = [];
          factoid_name = input_data.args.trim();
          factoid_content = _this.factoids[factoid_name];
          is_alias = /^alias:/.test(factoid_content);
          factoid_original_name = is_alias ? (factoid_content.match(/^alias:(.*)/))[1] : factoid_name;
          factoid_original_content = _this.factoids[factoid_original_name];
          aliases = _this.factoid_get_aliases(factoid_original_name);
          if (is_alias) {
            message.push("« " + factoid_name + " » is an alias for « " + factoid_original_name + " »");
          } else {
            message.push("« " + factoid_name + " » is not an alias");
          }
          if (aliases) {
            message.push("The following names are aliases for « " + factoid_original_name + " »: " + (aliases.join(' • ')));
          } else {
            message.push("There are no aliases for « " + factoid_original_name + " »");
          }
          message.push("« " + factoid_original_name + " » is « " + factoid_original_content + " »");
        }
        return _this.send('notice', event.person.nick, message);
      }
    });
    return this.register_special_command({
      name: 'search',
      description: 'Search the factoids store',
      admin_only: false,
      fn: function(event, input_data, output_data) {
        var factoid_content, factoid_name, flag_a, flag_c, flag_n, flag_o, is_alias, max_results, message, num_results, query, results, showing, _ref;
        if (__indexOf.call(input_data.flags, '?') >= 0) {
          message = ['Syntax: search[/oanc] • Search the factoids store', '--- This command supports the following flags ---', 'o • original: only search \'original\' factoids; that is, factoids that are not aliases', 'a • aliases: only search aliases', 'n • names: only search factoid names', 'c • content: only search factoid content', 'Note: flags \'o\' and \'a\' are mutually exclusive', 'Note: flags \'n\' and \'c\' are mutually exclusive'];
        } else if (!input_data.args) {
          message = 'Sorry, I didn\'t see a search term there!';
        } else {
          query = new RegExp(js.re_escape(input_data.args), 'i');
          results = [];
          max_results = 20;
          flag_n = __indexOf.call(input_data.flags, 'n') >= 0;
          flag_c = __indexOf.call(input_data.flags, 'c') >= 0;
          flag_o = __indexOf.call(input_data.flags, 'o') >= 0;
          flag_a = __indexOf.call(input_data.flags, 'a') >= 0;
          _ref = _this.factoids;
          for (factoid_name in _ref) {
            if (!__hasProp.call(_ref, factoid_name)) continue;
            factoid_content = _ref[factoid_name];
            is_alias = /^alias:/.test(factoid_content);
            if (flag_n && !flag_c) {
              if (query.test(factoid_name)) {
                if ((flag_a && !flag_o && is_alias) || (flag_o && !flag_a && !is_alias) || (!flag_a && !flag_o)) {
                  results.push(factoid_name);
                }
              }
            } else if (flag_c && !flag_n) {
              if (query.test(factoid_content)) {
                if ((flag_a && !flag_o && is_alias) || (flag_o && !flag_a && !is_alias) || (!flag_a && !flag_o)) {
                  results.push(factoid_name);
                }
              }
            } else {
              if ((query.test(factoid_name)) || (query.test(factoid_content))) {
                if ((flag_a && !flag_o && is_alias) || (flag_o && !flag_a && !is_alias) || (!flag_a && !flag_o)) {
                  results.push(factoid_name);
                }
              }
            }
          }
          if (results.length) {
            num_results = results.length;
            showing = num_results > max_results ? " (showing " + max_results + ")" : '';
            results = results.slice(0, max_results);
            message = "Found " + num_results + " results for query « " + input_data.args + " »" + showing + ": " + (results.join(' • '));
          } else {
            message = "Sorry, I couldn't find any results for query « " + input_data.args + " »";
          }
        }
        return _this.send('notice', event.person.nick, message);
      }
    });
  };

}).call(this);
