// Generated by IcedCoffeeScript 1.3.3d
(function() {
  'use strict';

  var fs, ignored_users, js, save_ignored_users, util,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  util = require('util');

  fs = require('fs');

  js = (require('js-extensions')).local;

  ignored_users = (function() {
    ignored_users = fs.readFileSync("" + (process.cwd()) + "/ignored-users.json", 'utf-8');
    if (ignored_users) return JSON.parse(ignored_users);
  })();

  save_ignored_users = function() {
    return fs.writeFile("" + (process.cwd()) + "/ignored-users.json", JSON.stringify(ignored_users, 'utf-8'));
  };

  module.exports = function() {
    var _this = this;
    this.register_special_command({
      name: 'raw',
      description: 'Send a raw IRC command',
      admin_only: true,
      fn: function(event, input_data, output_data) {
        return _this.irc.raw(input_data.args);
      }
    });
    this.register_special_command({
      name: 'set',
      description: 'Add or update a factoid',
      admin_only: true,
      fn: function(event, input_data, output_data) {
        var args_match, factoid_content, factoid_exists, factoid_name, message, regexp, regexp_find, regexp_flags, regexp_match, regexp_replace, target_factoid;
        if (__indexOf.call(input_data.flags, '?') >= 0) {
          message = ['Syntax: set[/r!] <factoid-name> = <factoid-content> • Add or update a factoid', '--- This command supports the following flags ---', 'r • regexp: enables regexp mode; <factoid-content> must be a sed-style (s///) substitution literal, conforming to JavaScript regular expression syntax', 'a • alias: alias mode; create an alias to an existing factoid: <factoid-content> becomes a factoid name instead', '! • force: this flag must be set to overwrite an existing factoid when not in regexp mode; otherwise a warning will be issued'];
        } else if (!(args_match = input_data.args.match(/^(.+)\s+=\s+(.+)/))) {
          message = 'Sorry, it looks like you\'re missing some arguments!';
        } else {
          factoid_name = args_match[1].trim();
          factoid_exists = factoid_name in _this.factoids;
          if (__indexOf.call(input_data.flags, 'a') >= 0) {
            target_factoid = args_match[2].trim();
            if (!(target_factoid in _this.factoids)) {
              message = "Sorry, I couldn't find an existing factoid with the name « " + target_factoid + " » to create an alias for";
            } else if (factoid_name === target_factoid) {
              message = "Sorry, I won't let you create a circular reference :)";
            } else if (factoid_exists && !(__indexOf.call(input_data.flags, '!') >= 0)) {
              message = "Sorry, a factoid with the name « " + factoid_name + " » already exists. If you want to overwrite this factoid, you must use the '!' flag";
            } else {
              if (/^alias:/.test(_this.factoids[target_factoid])) {
                target_factoid = _this.factoids[target_factoid].replace(/^alias:/, '');
              }
              _this.factoids[factoid_name] = "alias:" + target_factoid;
              _this.save_factoids();
              message = "I successfully created « " + factoid_name + " » as an alias for « " + target_factoid + " »";
            }
          } else if (__indexOf.call(input_data.flags, 'r') >= 0) {
            if (!factoid_exists) {
              message = "Sorry, but I couldn't find a factoid with the name « " + factoid_name + " »";
            } else {
              regexp_match = (js.str_reverse(args_match[2].trim())).match(/^(.*?)(?!\/\\)\/(.*?)(?!\/\\)\/(.+?)(?!\/\\)\/s$/);
              if (!regexp_match) {
                message = 'Sorry, that\'s an invalid regexp argument; the expected format is `<factoid-name> = s/<find>/<replace>/<flags>` where <find> is a JavaScript-compatible regular expression';
              } else {
                regexp_match = regexp_match.splice(1).reverse().map(function(item) {
                  return js.str_reverse(item);
                });
                regexp_find = regexp_match[0], regexp_replace = regexp_match[1], regexp_flags = regexp_match[2];
                regexp_find = regexp_find.replace('\\/', '\/');
                try {
                  regexp = new RegExp(regexp_find, regexp_flags);
                } catch (_error) {}
                if (!regexp) {
                  message = 'Sorry, the regular expression pattern you provided is invalid';
                } else {
                  _this.factoids[factoid_name] = _this.factoids[factoid_name].replace(regexp, regexp_replace);
                  _this.save_factoids();
                  message = "I successfully updated the factoid « " + factoid_name + " » with content « " + _this.factoids[factoid_name] + " »";
                }
              }
            }
          } else {
            if (factoid_exists && !(__indexOf.call(input_data.flags, '!') >= 0)) {
              message = "Sorry, a factoid with the name « " + factoid_name + " » already exists. If you want to overwrite this factoid, you must use the '!' flag";
            } else {
              factoid_content = args_match[2].trim();
              if (/^alias:/.test(factoid_content)) {
                message = "Sorry, but you can't create factoids of which the content starts with 'alias:'";
              } else {
                _this.factoids[factoid_name] = factoid_content;
                _this.save_factoids();
                message = "I successfully " + (factoid_exists ? 'updated' : 'added') + " the factoid « " + factoid_name + " »";
              }
            }
          }
        }
        return _this.send('notice', event.person.nick, message);
      }
    });
    this.register_special_command({
      name: 'del',
      description: 'Delete a factoid',
      admin_only: true,
      fn: function(event, input_data, output_data) {
        var alias, aliases, factoid_content, factoid_name, factoid_original_content, factoid_original_name, is_alias, message, _i, _len;
        if (__indexOf.call(input_data.flags, '?') >= 0) {
          message = ['Syntax: del[/!] <factoid-name> • Delete a factoid', '--- This command supports the following flags ---', '! • force: enables deletion of factoids that have aliases leading to it; will also delete all aliases'];
        } else if (!(input_data.args.trim() in _this.factoids)) {
          message = "Sorry, you can't delete a factoid that doesn't exist!";
        } else {
          factoid_name = input_data.args.trim();
          factoid_content = _this.factoids[factoid_name];
          is_alias = /^alias:/.test(factoid_content);
          factoid_original_name = is_alias ? (factoid_content.match(/^alias:(.*)/))[1] : factoid_name;
          factoid_original_content = _this.factoids[factoid_original_name];
          aliases = _this.factoid_get_aliases(factoid_original_name);
          if (is_alias) {
            delete _this.factoids[factoid_name];
            _this.save_factoids();
            message = "I successfully deleted factoid « " + factoid_name + " » which was an alias to « " + factoid_original_name + " »";
          } else if (!aliases) {
            delete _this.factoids[factoid_name];
            _this.save_factoids();
            message = "I successfully deleted factoid « " + factoid_name + " » which had the content « " + factoid_content + " »";
          } else {
            if (!(__indexOf.call(input_data.flags, '!') >= 0)) {
              message = "I noticed the factoid you're trying to delete has aliases leading to it (see « " + input_data.trigger + "info " + factoid_name + " »). If you want to delete this factoid, and all aliases leading to it, you must specify the '!' flag";
            } else {
              delete _this.factoids[factoid_name];
              for (_i = 0, _len = aliases.length; _i < _len; _i++) {
                alias = aliases[_i];
                delete _this.factoids[alias];
              }
              _this.save_factoids();
              message = "I successfully deleted the factoid « " + factoid_name + " » and all aliases leading to it. The deleted factoid's content was « " + factoid_content + " »";
            }
          }
        }
        return _this.send('notice', event.person.nick, message);
      }
    });
    this.register_special_command({
      name: 'ignore',
      description: 'Manage the list of ignored users',
      admin_only: true,
      fn: function(event, input_data, output_data) {
        var add_match, entry, host, ignore_match, index, match_found, message, nick, _i, _j, _len, _len1;
        if (__indexOf.call(input_data.flags, '?') >= 0) {
          message = ['Syntax: ignore[/lrc] [<nick> <host>] • Manage the list of ignored users. When no flag is specified, adds an entry (both <nick> and <host> are required; at most one of these may be the value `null` in order to not use it as a constraint).', '--- This command supports the following flags ---', 'l • list: display a list of ignored users', 'r • remove: remove an entry from the list; must be provided with both <nick> and <host>, as recorded in the list', 'c • clear: clear all entries from the list'];
        } else if (__indexOf.call(input_data.flags, 'l') >= 0) {
          message = [];
          if (ignored_users.length) {
            message.push("I have the following " + ignored_users.length + " users ignored:");
            for (_i = 0, _len = ignored_users.length; _i < _len; _i++) {
              entry = ignored_users[_i];
              host = entry.host === null ? '(null)' : entry.host;
              message.push("nick: " + entry.nick + " • host: " + host);
            }
          } else {
            message = "I don't currently have anyone on my ignore list";
          }
        } else if (__indexOf.call(input_data.flags, 'c') >= 0) {
          ignored_users = [];
          save_ignored_users();
          message = "I have cleared the list of ignored users";
        } else if (__indexOf.call(input_data.flags, 'r') >= 0) {
          ignore_match = input_data.args.trim().split(' ');
          if (ignore_match.length !== 2) {
            message = "Sorry, you must provide both <nick> and <host> and they must match the information in the list";
          } else {
            nick = ignore_match[0] === 'null' ? null : ignore_match[0];
            host = ignore_match[1] === 'null' ? null : ignore_match[1];
            match_found = false;
            for (index = _j = 0, _len1 = ignored_users.length; _j < _len1; index = ++_j) {
              entry = ignored_users[index];
              if (entry.nick === nick && entry.host === host) {
                ignored_users.splice(index, 1);
                save_ignored_users();
                match_found = true;
                message = "I have successfully removed the entry from the list of ignored users";
                break;
              }
            }
            if (!match_found) {
              message = "Sorry, I couldn't find that entry in the list of ignored users";
            }
          }
        } else {
          add_match = input_data.args.trim().split(' ');
          if (add_match.length !== 2) {
            message = "Sorry, you must provide both <nick> and <host>; at most one of these may be the value `null` in order to not use it as a constraint";
          } else {
            nick = add_match[0] === 'null' ? null : add_match[0];
            host = add_match[1] === 'null' ? null : add_match[1];
            if (nick === null && host === null) {
              message = "Sorry, <nick> and <host> cannot both be `null`";
            } else {
              ignored_users.push({
                nick: nick,
                host: host
              });
              save_ignored_users();
              message = "I successfully added the entry to the list of ignored users";
            }
          }
        }
        return _this.send('notice', event.person.nick, message);
      }
    });
    this.register_special_command({
      name: 'reload',
      description: 'Reload the bot (it really just kills the bot; if a supervisor is monitoring the process, it\'ll restart',
      admin_only: true,
      fn: function(event, input_data, output_data) {
        throw new Error('Force reload!');
      }
    });
    return this.register_message_callback(function(event, input_data, output_data) {
      var is_ignored_user, message;
      is_ignored_user = _this.user_match(ignored_users, {
        nick: event.person.nick,
        host: event.person.host
      });
      if (is_ignored_user) {
        message = "You're on my ignore list, so don't bother :)";
        _this.send('notice', event.person.nick, message);
        return false;
      } else {
        return true;
      }
    });
  };

}).call(this);
