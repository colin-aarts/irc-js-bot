
#	irc-bot-js-admin
#	----------------
#	Administration functionality for irc-js-bot
#	This is an official plug-in
#
#	Provides four bot commands: 'raw', 'set', 'del' and 'ignore'

'use strict'


util  = require 'util'
fs    = require 'fs'
js    = (require 'js-extensions').local



# Load the ignored users datastore
ignored_users = do ->
	ignored_users = fs.readFileSync "#{process.cwd()}/ignored-users.json", 'utf-8'
	return JSON.parse ignored_users if ignored_users


# Provide a function for saving the ignored users datastore
save_ignored_users = ->
	fs.writeFile "#{process.cwd()}/ignored-users.json", JSON.stringify ignored_users, 'utf-8'



module.exports = ->

	#
	#	Command: raw
	#

	@register_special_command
		name: 'raw'
		description: 'Send a raw IRC command'
		admin_only: true
		fn: (event, input_data, output_data) => @irc.raw input_data.args



	#
	#	Command: set
	#

	@register_special_command
		name: 'set'
		description: 'Add or update a factoid'
		admin_only: true
		fn: (event, input_data, output_data) =>

			if '?' in input_data.flags
				message = [
					'''Syntax: set[/r!] <factoid-name> = <factoid-content> • Add or update a factoid'''
					'''--- This command supports the following flags ---'''
					'''r • regexp: enables regexp mode; <factoid-content> must be a sed-style (s///) substitution literal, conforming to JavaScript regular expression syntax'''
					'''a • alias: alias mode; create an alias to an existing factoid: <factoid-content> becomes a factoid name instead'''
					'''! • force: this flag must be set to overwrite an existing factoid when not in regexp mode; otherwise a warning will be issued'''
				]

			else if not args_match = input_data.args.match /^(.+)\s+=\s+(.+)/
				message = '''Sorry, it looks like you're missing some arguments!'''

			else
				factoid_name = args_match[1].trim()
				factoid_exists = factoid_name of @factoids

				# Alias mode
				if 'a' in input_data.flags

					target_factoid = args_match[2].trim()

					if not (target_factoid of @factoids)
						message = """Sorry, I couldn't find an existing factoid with the name « #{target_factoid} » to create an alias for"""
					else if factoid_name is target_factoid
						message = """Sorry, I won't let you create a circular reference :)"""
					else if factoid_exists and not ('!' in input_data.flags)
						message = """Sorry, a factoid with the name « #{factoid_name} » already exists. If you want to overwrite this factoid, you must use the '!' flag"""
					else
						@factoids[factoid_name] = "alias:#{target_factoid}"
						@save_factoids()

						message = """I successfully created « #{factoid_name} » as an alias for « #{target_factoid} »"""

				# Regexp mode
				else if 'r' in input_data.flags

					# In regexp mode, we can't create a new factoid, only update existing ones
					if not factoid_exists
						message = """Sorry, but I couldn't find a factoid with the name « #{factoid_name} »"""

					else
						# We're matching a regexp in the form s///, but JS doesn't have look-behind, so we're matching in reverse and using look-ahead instead
						regexp_match = (js.str_reverse args_match[2].trim()).match ///
							^
							(.*?)		# Flags
							(?!/\\)		# NOT /\
							/			# /
							(.*?)		# Replacement
							(?!/\\)		# NOT /\
							/			# /
							(.+?)		# Find pattern
							(?!/\\)		# NOT /\
							/s			# /s
							$
							///

						if not regexp_match
							message = '''Sorry, that's an invalid regexp argument; the expected format is `<factoid-name> = s/<find>/<replace>/<flags>` where <find> is a JavaScript-compatible regular expression'''

						else
							# Undo the reversal
							regexp_match = regexp_match.splice(1).reverse().map (item) -> return js.str_reverse item

							[regexp_find, regexp_replace, regexp_flags] = regexp_match

							regexp_find = regexp_find.replace '\\/', '\/'
							try regexp = new RegExp regexp_find, regexp_flags

							if not regexp
								message = '''Sorry, the regular expression pattern you provided is invalid'''
							else
								@factoids[factoid_name] = @factoids[factoid_name].replace regexp, regexp_replace
								@save_factoids()

								message = """I successfully updated the factoid « #{factoid_name} » with content « #{@factoids[factoid_name]} »"""

				# Normal assignment mode
				else
					if factoid_exists and not ('!' in input_data.flags)
						message = """Sorry, a factoid with the name « #{factoid_name} » already exists. If you want to overwrite this factoid, you must use the '!' flag"""

					else
						factoid_content = args_match[2].trim()

						if /^alias:/.test factoid_content
							message = "Sorry, but you can't create factoids of which the content starts with 'alias:'"
						else
							@factoids[factoid_name] = factoid_content
							@save_factoids()

							message = """I successfully #{if factoid_exists then 'updated' else 'added'} the factoid « #{factoid_name} »"""

			@send 'notice', event.person.nick, message



	#
	#	Command: del
	#

	@register_special_command
		name: 'del'
		description: 'Delete a factoid'
		admin_only: true
		fn: (event, input_data, output_data) =>

			if '?' in input_data.flags
				message = [
					'''Syntax: del[/!] <factoid-name> • Delete a factoid'''
					'''--- This command supports the following flags ---'''
					'''! • force: enables deletion of factoids that have aliases leading to it; will also delete all aliases'''
				]

			else if not (input_data.args.trim() of @factoids)
				message = """Sorry, you can't delete a factoid that doesn't exist!"""

			else
				factoid_name = input_data.args.trim()
				factoid_content = @factoids[factoid_name]
				is_alias = /^alias:/.test factoid_content
				factoid_original_name = if is_alias then (factoid_content.match /^alias:(.*)/)[1] else factoid_name
				factoid_original_content = @factoids[factoid_original_name]
				aliases = @factoid_get_aliases factoid_original_name

				if is_alias
					delete @factoids[factoid_name]
					@save_factoids()

					message = """I successfully deleted factoid « #{factoid_name} » which was an alias to « #{factoid_original_name} »"""

				else if not aliases
					delete @factoids[factoid_name]
					@save_factoids()

					message = """I successfully deleted factoid « #{factoid_name} » which had the content « #{factoid_content} »"""

				# Else, the factoid is an original, with aliases leading to it.
				else
					if not ('!' in input_data.flags)
						message = """I noticed the factoid you're trying to delete has aliases leading to it (see « #{input_data.trigger}info #{factoid_name} »). If you want to delete this factoid, and all aliases leading to it, you must specify the '!' flag"""

					else
						delete @factoids[factoid_name]
						delete @factoids[alias] for alias in aliases
						@save_factoids()

						message = """I successfully deleted the factoid « #{factoid_name} » and all aliases leading to it. The deleted factoid's content was « #{factoid_content} »"""

			@send 'notice', event.person.nick, message



	#
	#	Command: ignore
	#

	@register_special_command
		name: 'ignore'
		description: 'Manage the list of ignored users'
		admin_only: true
		fn: (event, input_data, output_data) =>

			if '?' in input_data.flags
				message = [
					'''Syntax: ignore[/lrc] [<nick> <host>] • Manage the list of ignored users. When no flag is specified, adds an entry (both <nick> and <host> are required; at most one of these may be the value `null` in order to not use it as a constraint).'''
					'''--- This command supports the following flags ---'''
					'''l • list: display a list of ignored users'''
					'''r • remove: remove an entry from the list; must be provided with both <nick> and <host>, as recorded in the list'''
					'''c • clear: clear all entries from the list'''
				]

			# List mode
			else if 'l' in input_data.flags
				message = []
				if ignored_users.length
					message.push "I have the following #{ignored_users.length} users ignored:"
					for entry in ignored_users
						host = if entry.host is null then '(null)' else entry.host
						message.push "nick: #{entry.nick} • host: #{host}"
				else
					message = "I don't currently have anyone on my ignore list"

			# Clear mode
			else if 'c' in input_data.flags
				ignored_users = []
				save_ignored_users()
				message = "I have cleared the list of ignored users"

			# Remove mode
			else if 'r' in input_data.flags
				ignore_match = input_data.args.trim().split ' '

				if ignore_match.length isnt 2
					message = "Sorry, you must provide both <nick> and <host> and they must match the information in the list"

				else
					nick = if ignore_match[0] is 'null' then null else ignore_match[0]
					host = if ignore_match[1] is 'null' then null else ignore_match[1]
					match_found = false

					for entry, index in ignored_users
						if entry.nick is nick and
						   entry.host is host
							ignored_users.splice index, 1
							save_ignored_users()
							match_found = true
							message = "I have successfully removed the entry from the list of ignored users"
							break

					if not match_found
						message = "Sorry, I couldn't find that entry in the list of ignored users"

			# Add mode
			else
				add_match = input_data.args.trim().split ' '

				if add_match.length isnt 2
					message = "Sorry, you must provide both <nick> and <host>; at most one of these may be the value `null` in order to not use it as a constraint"

				else
					nick = if add_match[0] is 'null' then null else add_match[0]
					host = if add_match[1] is 'null' then null else add_match[1]

					if nick is null and
					   host is null
						message = "Sorry, <nick> and <host> cannot both be `null`"

					else
						ignored_users.push { nick: nick, host: host }
						save_ignored_users()
						message = "I successfully added the entry to the list of ignored users"

			@send 'notice', event.person.nick, message



	#
	#	Callbacks
	#

	@register_message_callback (event, input_data, output_data) =>

			# See if the sender is on the ignore list
			is_ignored_user = false
			for user in ignored_users

				# User is considered an ignored user if one of the following conditions is met:
				# • nick matches registered nick, and no host is registered (null), -or-
				# • host matches registered host, and no nick is registered (null), -or-
				# • both match.
				# This means that if both nick and host are registered, both *must* match.
				# Note: registered host is compared to the end of the host string as sent by the server (i.e. /<host>$/).
				is_host_match = if user.host isnt null then (new RegExp "#{js.re_escape user.host}$", 'i').test event.person.host else false

				if (user.nick and user.nick is event.person.nick and not user.host) or
				   (user.host and is_host_match and not admin.nick) or
				   (user.host and is_host_match and user.nick and user.nick is event.person.nick)
					is_ignored_user = true

			if is_ignored_user
				message = "You're on my ignore list, so don't bother :)"
				@send 'notice', event.person.nick, message
				return false
			else
				return true

